中央式：

	1. 没有本地仓库的，本地只有一份你签出的代码和最基本的版本信息（服务器在哪，以及一些关于版本号的缓存什么的）。
	2. 中央式VCS, 你本地只有一份从中央仓库pull下来指定分支代码,  断网你啥也干不了, 
	想管理自己的版本只能依赖比如: IDEA的History功能, 你save一次就一个版本。
	
分布式：

	1. 有带版本管理的本地仓库，有所有人提交的版本记录，可以离线做一些提交，回滚、查看历史、分支操作。
	2. 可以实现不依赖于IDEA的history功能进行精确的版本管理。
	
创建一个 git-practice 项目：

1.工作目录： 就是根目录，即 git-practice 
2.本地仓库： .git 目录

commint 的时候会进入一个编辑界面： i(插入模式) -esc(变回命令模式) -大写两次ZZ(退出并保存 )

因为 Git 的push 其实是用本地仓库的 commits 记录去覆盖远端仓库的 commits 记录
（注：这是简化概念后的说法，push 的实质和这个说法略有不同），而如果在远端仓库
含有本地没有的 commits 的时候，push （如果成功）将会导致远端的 commits 被擦掉。
这种结果当然是不可行的，因此 Git 会在 push 的时候进行检查，如果出现这样的情况，push 就会失败。

HEAD 是 Git 中一个独特的引用，它是唯一的。

注意：

当有人使用 git clone 时，除了从远程仓库把 .git 这个仓库目录下载到工作目录中，
还会 checkout （签出） master（checkout 的意思就是把某个 commit 作为当前 commit，
把 HEAD 移动过去，并把工作目录的文件内容替换成这个 commit 所对应的内容）。

所以刚 clone 的代码默认是处于 master 分支的最新提交位置内容。

branch 包含了从初始 commit 到它的所有路径，而不是一条路径。并且，这些路径之间也是彼此平等的。

注意：

由于 Git 中的 branch 只是一个引用，所以删除 branch 的操作也只会删掉这个引用，
并不会删除任何的 commit。（不过如果一个 commit 不在任何一个 branch 的「路径」上，
或者换句话说，如果没有任何一个 branch 可以回溯到这条 commit（也许可以称为野生 commit？）
，那么在一定时间后，它会被 Git 的回收机制删除掉。）

比如：有分㕚的不同分支，其中的一个分支有提交过，但是从来没被合并，但是分支引用却被删除了，
那么这些还没被合并的 commits 将会被回收掉。





















