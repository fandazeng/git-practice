中央式：

	1. 没有本地仓库的，本地只有一份你签出的代码和最基本的版本信息（服务器在哪，以及一些关于版本号的缓存什么的）。
	2. 中央式VCS, 你本地只有一份从中央仓库pull下来指定分支代码,  断网你啥也干不了, 
	想管理自己的版本只能依赖比如: IDEA的History功能, 你save一次就一个版本。
	
分布式：

	1. 有带版本管理的本地仓库，有所有人提交的版本记录，可以离线做一些提交，回滚、查看历史、分支操作。
	2. 可以实现不依赖于IDEA的history功能进行精确的版本管理。
	
创建一个 git-practice 项目：

1.工作目录： 就是根目录，即 git-practice 
2.本地仓库： .git 目录


commint 的时候会进入一个编辑界面： i(插入模式) -esc(变回命令模式) -大写两次ZZ(退出并保存 )

因为 Git 的push 其实是用本地仓库的 commits 记录去覆盖远端仓库的 commits 记录
（注：这是简化概念后的说法，push 的实质和这个说法略有不同），而如果在远端仓库
含有本地没有的 commits 的时候，push （如果成功）将会导致远端的 commits 被擦掉。
这种结果当然是不可行的，因此 Git 会在 push 的时候进行检查，如果出现这样的情况，push 就会失败。

HEAD 是 Git 中一个独特的引用，它是唯一的。

注意：

当有人使用 git clone 时，除了从远程仓库把 .git 这个仓库目录下载到工作目录中，
还会 checkout （签出） master（checkout 的意思就是把某个 commit 作为当前 commit，
把 HEAD 移动过去，并把工作目录的文件内容替换成这个 commit 所对应的内容）。

所以刚 clone 的代码默认是处于 master 分支的最新提交位置内容。

branch 包含了从初始 commit 到它的所有路径，而不是一条路径。并且，这些路径之间也是彼此平等的。

























